'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var axios = require('axios');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

// src/index.ts
var CrossEnvConfig = class {
  /**
   * Get a config value from either the environment or any registry overrides
   * @param prop
   */
  static get(prop) {
    return this.safeEnvLookup(prop);
  }
  /**
   * Set a value explicitly
   *
   * @param key
   * @param value
   */
  static set(key, value) {
    return this._overrides.set(key, value);
  }
  /**
   * Alias a key to another key if helpful. This is useful if you have different naming
   * constructs for different environments.
   *
   * @param from
   * @param to
   */
  static alias(from, to) {
    return this._aliases.set(from, to);
  }
  /**
   * Helpful if you've decided to store settings in another object and want to
   * make that available here. For example in client-side implementations you may reserve
   * a window.FLATFILE_CONFIG object to store settings.
   *
   * @param obj
   */
  static attachConfigRegistry(obj) {
    this._registry = obj;
  }
  /**
   * Use this to provide an override getter for config values. This is useful
   * if you need to dynamically look up values. Overrides will still take precedence.
   *
   * @param cb
   */
  static attachConfigFactory(cb) {
    this._factory = cb;
  }
  static reset() {
    this._overrides = /* @__PURE__ */ new Map();
    this._registry = void 0;
    this._factory = void 0;
  }
  /**
   * Internal function for traversing the possible environment sources for a value
   *
   * @param prop
   * @private
   */
  static safeEnvLookup(prop) {
    let values = [];
    if (this._overrides.get(prop)) {
      values.push(this._overrides.get(prop));
    }
    if (typeof this._registry === "object") {
      values.push(this._registry[prop]);
    }
    if (typeof this._factory === "function") {
      values.push(this._factory(prop));
    }
    if (typeof process === "object" && typeof process.env === "object") {
      values.push(process.env[prop]);
    }
    values.push(...this.checkForBrowserVariables(prop));
    const foundValue = values.find((v) => v !== void 0);
    if (foundValue !== void 0) {
      return foundValue;
    }
    const alias = this._aliases.get(prop);
    if (alias) {
      return this.safeEnvLookup(alias);
    }
    return void 0;
  }
  /**
   * Internal function for checking for stored variables in a browser-like environment
   *
   * @param prop
   * @private
   */
  static checkForBrowserVariables(prop) {
    let values = [];
    if (typeof window === "object") {
      const windowValue = window[`CROSSENV_${prop}`];
      if (windowValue !== void 0) {
        values.push(windowValue);
      }
      if (typeof sessionStorage === "object") {
        const storedValue = sessionStorage.getItem(`CROSSENV_${prop}`);
        if (storedValue !== null) {
          values.push(storedValue);
        }
      }
    }
    return values;
  }
};
CrossEnvConfig._overrides = /* @__PURE__ */ new Map();
/**
 * A map of aliases that can be used to look up config values.
 *
 * @private
 */
CrossEnvConfig._aliases = /* @__PURE__ */ new Map();

const ensureSingleTrailingSlash = (url) => {
    // Remove all trailing slashes
    while (url.endsWith('/')) {
        url = url.slice(0, -1);
    }
    // Append one slash
    return url + '/';
};

class AuthenticatedClient {
    constructor(accessToken, apiUrl) {
        const FLATFILE_API_URL = CrossEnvConfig.get('AGENT_INTERNAL_URL') || 'http://localhost:3000';
        const bearerToken = CrossEnvConfig.get('FLATFILE_BEARER_TOKEN');
        this._accessToken = accessToken || bearerToken || '...';
        this._apiUrl =
            apiUrl || FLATFILE_API_URL
                ? ensureSingleTrailingSlash(apiUrl || FLATFILE_API_URL)
                : undefined;
    }
    async fetch(url, options) {
        const headers = {
            Authorization: `Bearer ${this._accessToken}`,
            'x-disable-hooks': 'true',
        };
        const axiosInstance = axios__default["default"].create({
            headers,
            validateStatus: (status) => {
                return status >= 200 && status <= 399;
            },
        });
        const fetchUrl = this._apiUrl + url;
        const config = {
            url: fetchUrl,
            method: 'GET',
            ...options,
        };
        try {
            const resp = await axiosInstance(config);
            return resp.data.data;
        }
        catch (err) {
            console.log('event.fetch error: ', err);
        }
    }
    /**
     *
     * @deprecated use @flatfile/cross-env-config instead
     */
    setVariables({ accessToken, apiUrl, }) {
        this._accessToken = accessToken;
        this._apiUrl = apiUrl;
    }
}

class EventCache {
    constructor() {
        this.eventCache = new Map();
    }
    async init(key, callback) {
        if (this.eventCache.get(key)) {
            return this.eventCache.get(key);
        }
        else {
            const result = await callback();
            this.eventCache.set(key, result);
            return result;
        }
    }
    async set(key, callback) {
        if (this.eventCache.get(key)) {
            const result = await callback();
            this.eventCache.set(key, result);
            return result;
        }
        else {
            throw new Error('Cache key not found');
        }
    }
    get(key) {
        if (this.eventCache.get(key)) {
            return this.eventCache.get(key);
        }
        else {
            throw new Error('Cache key not found');
        }
    }
    delete(key) {
        if (!key) {
            this.eventCache.clear();
        }
        else if (this.eventCache.get(key)) {
            if (Array.isArray(key)) {
                key.forEach((k) => this.eventCache.delete(k));
            }
            else {
                this.eventCache.delete(key);
            }
        }
        else {
            throw new Error('Cache key not found');
        }
    }
}

class FlatfileEvent extends AuthenticatedClient {
    constructor(src, accessToken, apiUrl) {
        super(accessToken, apiUrl);
        this.src = src;
        this.afterAllCallbacks = new Map();
        this.cache = new EventCache();
        this.domain = src.domain;
        this.topic = src.topic;
        this.context = src.context; // -> [us0_acc_ihjh8943h9w, space_id, workbook_id]
        this.payload = src.payload;
        this.target = src.target || '';
        this.origin = src.origin || {};
        this.action = src.context?.actionName || '';
        this.namespace = src.namespaces || [];
        this.createdAt = src.createdAt || undefined;
        const data = async (options) => this.fetchData(options);
        data.then = (onfulfilled, onrejected) => {
            return this.data().then(onfulfilled, onrejected);
        };
        this.data = data;
    }
    /**
     * Should return either event body if expanded already or fetch data from the
     * signed dataURL
     */
    async fetchData(options) {
        const dataUrl = new URLSearchParams(this.src.dataUrl);
        if (options) {
            for (const [key, values] of Object.entries(options)) {
                if (Array.isArray(values)) {
                    for (const value of values) {
                        dataUrl.append(key, value);
                    }
                }
                else {
                    dataUrl.append(key, values);
                }
            }
        }
        const decodedURL = decodeURIComponent(dataUrl.toString());
        if (decodedURL) {
            return this.fetch(decodedURL);
        }
        else {
            return this.payload;
        }
    }
    afterAll(callback, cacheKey) {
        const key = cacheKey || callback.toString();
        if (!this.afterAllCallbacks.get(key)) {
            this.afterAllCallbacks.set(key, callback);
        }
    }
    async update(records) {
        if (!this.src.dataUrl) {
            throw new Error('Cannot set data on an event without a dataUrl');
        }
        // TODO: do we need to remove source from the messages array?
        records.map((record) => {
            record.messages?.map((message) => {
                delete message.source;
            });
        });
        await this.fetch(this.src.dataUrl, {
            method: 'PUT',
            data: records,
        });
    }
    /**
     * Fetch the Secrets as indicated by this event context
     *
     * @param key - The name of the secret to fetch
     * @param options - (Optional) environmentId and spaceId to override event context
     *
     * @returns The value of the secret (usually a credential or token)
     */
    async secrets(key, options) {
        // Allow options overrides, then take from context, else are absent
        const environmentId = options?.environmentId || this.context.environmentId || '';
        const spaceId = options?.spaceId || this.context.spaceId || '';
        if (!environmentId) {
            throw new Error('environmentId is required to fetch secrets');
        }
        let getSecrets = `v1/secrets?environmentId=${environmentId}`;
        if (spaceId) {
            getSecrets += `&spaceId=${spaceId}`;
        }
        const secretCacheKey = `secrets:${environmentId}${spaceId && `:${spaceId}`}`;
        const secrets = await this.cache.init(secretCacheKey, async () => {
            const secretsResponse = await this.fetch(getSecrets);
            const SecretMap = new Map();
            secretsResponse?.forEach((secret) => {
                SecretMap.set(secret.name, secret.value);
            });
            return SecretMap;
        });
        const value = secrets.get(key);
        if (!value) {
            throw new Error(`Secret ${key} not found`);
        }
        return value;
    }
}

/**
 * Escapes a character if it has a special meaning in regular expressions
 * and returns the character as is if it doesn't
 */
function escapeRegExpChar(char) {
    if (char === '-' ||
        char === '^' ||
        char === '$' ||
        char === '+' ||
        char === '.' ||
        char === '(' ||
        char === ')' ||
        char === '|' ||
        char === '[' ||
        char === ']' ||
        char === '{' ||
        char === '}' ||
        char === '*' ||
        char === '?' ||
        char === '\\') {
        return "\\" + char;
    }
    else {
        return char;
    }
}
/**
 * Escapes all characters in a given string that have a special meaning in regular expressions
 */
function escapeRegExpString(str) {
    var result = '';
    for (var i = 0; i < str.length; i++) {
        result += escapeRegExpChar(str[i]);
    }
    return result;
}
/**
 * Transforms one or more glob patterns into a RegExp pattern
 */
function transform(pattern, separator) {
    if (separator === void 0) { separator = true; }
    if (Array.isArray(pattern)) {
        var regExpPatterns = pattern.map(function (p) { return "^" + transform(p, separator) + "$"; });
        return "(?:" + regExpPatterns.join('|') + ")";
    }
    var separatorSplitter = '';
    var separatorMatcher = '';
    var wildcard = '.';
    if (separator === true) {
        separatorSplitter = '/';
        separatorMatcher = '[/\\\\]';
        wildcard = '[^/\\\\]';
    }
    else if (separator) {
        separatorSplitter = separator;
        separatorMatcher = escapeRegExpString(separatorSplitter);
        if (separatorMatcher.length > 1) {
            separatorMatcher = "(?:" + separatorMatcher + ")";
            wildcard = "((?!" + separatorMatcher + ").)";
        }
        else {
            wildcard = "[^" + separatorMatcher + "]";
        }
    }
    var requiredSeparator = separator ? separatorMatcher + "+?" : '';
    var optionalSeparator = separator ? separatorMatcher + "*?" : '';
    var segments = separator ? pattern.split(separatorSplitter) : [pattern];
    var result = '';
    for (var s = 0; s < segments.length; s++) {
        var segment = segments[s];
        var nextSegment = segments[s + 1];
        var currentSeparator = '';
        if (!segment && s > 0) {
            continue;
        }
        if (separator) {
            if (s === segments.length - 1) {
                currentSeparator = optionalSeparator;
            }
            else if (nextSegment !== '**') {
                currentSeparator = requiredSeparator;
            }
            else {
                currentSeparator = '';
            }
        }
        if (separator && segment === '**') {
            if (currentSeparator) {
                result += s === 0 ? '' : currentSeparator;
                result += "(?:" + wildcard + "*?" + currentSeparator + ")*?";
            }
            continue;
        }
        for (var c = 0; c < segment.length; c++) {
            var char = segment[c];
            if (char === '\\') {
                if (c < segment.length - 1) {
                    result += escapeRegExpChar(segment[c + 1]);
                    c++;
                }
            }
            else if (char === '?') {
                result += wildcard;
            }
            else if (char === '*') {
                result += wildcard + "*?";
            }
            else {
                result += escapeRegExpChar(char);
            }
        }
        result += currentSeparator;
    }
    return result;
}

function isMatch(regexp, sample) {
    if (typeof sample !== 'string') {
        throw new TypeError("Sample must be a string, but " + typeof sample + " given");
    }
    return regexp.test(sample);
}
/**
 * Compiles one or more glob patterns into a RegExp and returns an isMatch function.
 * The isMatch function takes a sample string as its only argument and returns `true`
 * if the string matches the pattern(s).
 *
 * ```js
 * wildcardMatch('src/*.js')('src/index.js') //=> true
 * ```
 *
 * ```js
 * const isMatch = wildcardMatch('*.example.com', '.')
 * isMatch('foo.example.com') //=> true
 * isMatch('foo.bar.com') //=> false
 * ```
 */
function wildcardMatch(pattern, options) {
    if (typeof pattern !== 'string' && !Array.isArray(pattern)) {
        throw new TypeError("The first argument must be a single pattern string or an array of patterns, but " + typeof pattern + " given");
    }
    if (typeof options === 'string' || typeof options === 'boolean') {
        options = { separator: options };
    }
    if (arguments.length === 2 &&
        !(typeof options === 'undefined' ||
            (typeof options === 'object' && options !== null && !Array.isArray(options)))) {
        throw new TypeError("The second argument must be an options object or a string/boolean separator, but " + typeof options + " given");
    }
    options = options || {};
    if (options.separator === '\\') {
        throw new Error('\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead');
    }
    var regexpPattern = transform(pattern, options.separator);
    var regexp = new RegExp("^" + regexpPattern + "$", options.flags);
    var fn = isMatch.bind(null, regexp);
    fn.options = options;
    fn.pattern = pattern;
    fn.regexp = regexp;
    return fn;
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var flat = flatten;
flatten.flatten = flatten;
flatten.unflatten = unflatten;

function isBuffer (obj) {
  return obj &&
    obj.constructor &&
    (typeof obj.constructor.isBuffer === 'function') &&
    obj.constructor.isBuffer(obj)
}

function keyIdentity (key) {
  return key
}

function flatten (target, opts) {
  opts = opts || {};

  const delimiter = opts.delimiter || '.';
  const maxDepth = opts.maxDepth;
  const transformKey = opts.transformKey || keyIdentity;
  const output = {};

  function step (object, prev, currentDepth) {
    currentDepth = currentDepth || 1;
    Object.keys(object).forEach(function (key) {
      const value = object[key];
      const isarray = opts.safe && Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isbuffer = isBuffer(value);
      const isobject = (
        type === '[object Object]' ||
        type === '[object Array]'
      );

      const newKey = prev
        ? prev + delimiter + transformKey(key)
        : transformKey(key);

      if (!isarray && !isbuffer && isobject && Object.keys(value).length &&
        (!opts.maxDepth || currentDepth < maxDepth)) {
        return step(value, newKey, currentDepth + 1)
      }

      output[newKey] = value;
    });
  }

  step(target);

  return output
}

function unflatten (target, opts) {
  opts = opts || {};

  const delimiter = opts.delimiter || '.';
  const overwrite = opts.overwrite || false;
  const transformKey = opts.transformKey || keyIdentity;
  const result = {};

  const isbuffer = isBuffer(target);
  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {
    return target
  }

  // safely ensure that the key is
  // an integer.
  function getkey (key) {
    const parsedKey = Number(key);

    return (
      isNaN(parsedKey) ||
      key.indexOf('.') !== -1 ||
      opts.object
    ) ? key
      : parsedKey
  }

  function addKeys (keyPrefix, recipient, target) {
    return Object.keys(target).reduce(function (result, key) {
      result[keyPrefix + delimiter + key] = target[key];

      return result
    }, recipient)
  }

  function isEmpty (val) {
    const type = Object.prototype.toString.call(val);
    const isArray = type === '[object Array]';
    const isObject = type === '[object Object]';

    if (!val) {
      return true
    } else if (isArray) {
      return !val.length
    } else if (isObject) {
      return !Object.keys(val).length
    }
  }

  target = Object.keys(target).reduce(function (result, key) {
    const type = Object.prototype.toString.call(target[key]);
    const isObject = (type === '[object Object]' || type === '[object Array]');
    if (!isObject || isEmpty(target[key])) {
      result[key] = target[key];
      return result
    } else {
      return addKeys(
        key,
        result,
        flatten(target[key], opts)
      )
    }
  }, {});

  Object.keys(target).forEach(function (key) {
    const split = key.split(delimiter).map(transformKey);
    let key1 = getkey(split.shift());
    let key2 = getkey(split[0]);
    let recipient = result;

    while (key2 !== undefined) {
      if (key1 === '__proto__') {
        return
      }

      const type = Object.prototype.toString.call(recipient[key1]);
      const isobject = (
        type === '[object Object]' ||
        type === '[object Array]'
      );

      // do not write over falsey, non-undefined values if overwrite is false
      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {
        return
      }

      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {
        recipient[key1] = (
          typeof key2 === 'number' &&
          !opts.object ? [] : {}
        );
      }

      recipient = recipient[key1];
      if (split.length > 0) {
        key1 = getkey(split.shift());
        key2 = getkey(split[0]);
      }
    }

    // unflatten again for 'messy objects'
    recipient[key1] = unflatten(target[key], opts);
  });

  return result
}

var flat$1 = /*@__PURE__*/getDefaultExportFromCjs(flat);

/**
 * Glob style matching of a value
 *
 * @param val
 * @param filter
 */
function glob(val, filter) {
    if (!val || typeof val !== 'string') {
        return false;
    }
    return wildcardMatch(filter || '**', ':')(val);
}
/**
 * Glob style matching of values in an object
 *
 * @param object
 * @param filterObject
 */
function objectMatches(object, filterObject) {
    const cleanFilter = !filterObject || typeof filterObject !== 'object'
        ? { '**': filterObject }
        : filterObject;
    if (typeof object !== 'object') {
        throw new Error('You cannot filter a non-object');
    }
    let denied = false;
    const filter = flat$1(cleanFilter, { safe: true });
    const flattened = flat$1(object, { safe: true });
    // all filters MUST resolve true
    for (const keyPattern in filter) {
        const keys = filterKeys(flattened, keyPattern);
        const valuePattern = (Array.isArray(filter[keyPattern])
            ? filter[keyPattern]
            : [filter[keyPattern]]);
        // only one filter must match
        denied || (denied = !keys.some((key) => {
            const value = flattened[key];
            return valuePattern.some((match) => globOrMatch(value, match));
        }));
    }
    return !denied;
}
/**
 * Glob keys of an object and return the narrowed set
 *
 * @param object
 * @param glob
 */
function filterKeys(object, glob) {
    glob = glob.includes('*') || glob.includes('.') ? glob : `**.${glob}`;
    const matcher = wildcardMatch(glob, '.');
    return Object.keys(object).filter((key) => matcher(key));
}
function globOrMatch(val, filter) {
    if (val === undefined || val === null) {
        return filter === null;
    }
    if (Array.isArray(val)) {
        return val.some((v) => globOrMatch(v, filter));
    }
    if (typeof filter === 'string') {
        return glob(val.toString(), filter);
    }
    // otherwise do a simple comparison
    return val === filter;
}

/**
 * EventHandler is a Flatfile flavored implementation of EventTarget
 */
class EventHandler extends AuthenticatedClient {
    constructor(filter, accessToken, apiUrl) {
        super(accessToken, apiUrl);
        /**
         * Cache of registered listeners on this instance
         * @private
         */
        this.listeners = [];
        /**
         * Cache of registered child nodes for this listener. These nodes will
         * only receive events that pass the parent filter.
         *
         * @private
         */
        this.nodes = [];
        if (filter) {
            this.filterQuery = filter;
        }
    }
    on(query, ...rest) {
        let filter = {};
        const callback = rest.pop();
        if (rest.length) {
            filter = rest.shift();
        }
        this.listeners.push([query, filter, callback]);
        return this;
    }
    /**
     * Add child nodes to send this event to as well
     *
     * @param node
     */
    addNode(node) {
        this.nodes.push(node);
        return this;
    }
    /**
     * Dispatch an event and resolve the promise once it has completed (or
     * errored
     *
     * @todo - is there a right order in which to resolve event listeners?
     *   Should it matter?
     *
     * @param event
     */
    async dispatchEvent(event) {
        if (!event)
            return;
        const eventPayload = event.src ? event.src : event;
        event = new FlatfileEvent(eventPayload, this._accessToken, this._apiUrl);
        await this.trigger(event, true);
        for (const [_key, cb] of event.afterAllCallbacks) {
            await cb(event);
        }
        event.cache.delete();
    }
    /**
     * @deprecated legacy shim for receiving events from the VM layer
     * @alias dispatchEvent
     * @param event
     */
    async routeEvent(event) {
        return this.dispatchEvent(event);
    }
    /**
     * Actually trigger the event listeners on this particular target
     *
     * @note It is safer for now to run this in series to avoid IO locks and
     *       potential race conditions and uncaught errors
     *
     * @param event
     * @param recursive
     */
    async trigger(event, recursive = false) {
        const listeners = this.getListeners(event, recursive);
        for (const cb of listeners) {
            await cb.callback(event);
        }
    }
    /**
     * Get any listeners from this target subscribing to this event
     *
     * @param event
     * @param recursive
     */
    getListeners(event, recursive = false) {
        // never return any listeners if the event doesn't match the filter
        // event recursion should not occur either
        if (!this.matchEvent(event, this.filterQuery)) {
            return [];
        }
        // look at listeners registered here
        const listeners = this.listeners
            .filter(([query, filter]) => {
            const globbed = glob(event.topic, query);
            const matched = this.matchEvent(event, filter);
            return globbed && matched;
        })
            .map(([query, filter, callback]) => ({ query, filter, callback }));
        return !recursive
            ? listeners
            : [
                ...listeners,
                ...this.nodes.flatMap((n) => n.getListeners(event, true)),
            ];
    }
    /**
     * Attach more event listeners using a callback function. Used most
     * frequently for plugins.
     *
     * @param fn
     */
    use(fn) {
        fn(this);
        return this;
    }
    /**
     * Filter an event out based on glob filter object
     *
     * @param event
     * @param filter
     */
    matchEvent(event, filter) {
        return filter ? objectMatches(event, filter) : true;
    }
}

/**
 * The Flatfile Listener
 *
 * The Flatfile PubSub Client is just a simple event subscriber. It can
 * receive events from any PubSub driver. The default drivers are:
 *
 * - Webhook    (for simply processing events sent to URL)
 * - Websocket  (for subscribing real time on an HTTP2 connection)
 * - Serverless (for stateless invocations via AWS Lambda or similar)
 *
 * Once an event is received, it is routed to any awaiting listeners which
 * are added with `addEventListener()` or its alias `on()`.
 *
 * Flatfile events follow a standard structure and event listeners can use
 * any of the following syntaxes to react to events within Flatfile.
 *
 * // listen to an event
 * addEventListener('entity:topic')
 *
 * // listen to an event on a specific namespace
 * addEventListener('entity:topic@namespace')
 *
 * // listen to a specific context on a namespace
 * addEventListener('entity:topic@namespace?context=us_sp_89234oihsdo')
 *
 * // filter by any
 * addEventListener('entity:topic@namespace?')
 *
 */
class FlatfileListener extends EventHandler {
    /**
     * Subscribe to events only within a certain namespace.
     *
     * @param namespace
     * @param cb
     */
    namespace(namespaces, cb) {
        return this.filter({ namespaces }, cb);
    }
    /**
     * Filter by namespace
     *
     * @param filter
     * @param cb
     */
    filter(filter, cb) {
        const client = new this.constructor(filter);
        this.addNode(client);
        cb?.(client);
        return client;
    }
    /**
     * Start subscribing to events
     *
     * @param cb
     */
    static create(cb) {
        const client = new this();
        cb(client);
        return client;
    }
    /**
     * Mount this client using an acceptable Event Driver
     */
    mount(driver) {
        driver.mountEventHandler(this);
        return this;
    }
}

class EventDriver {
    get handler() {
        if (!this._handler) {
            throw new Error('handler not registered yet');
        }
        return this._handler;
    }
    /**
     * Mount an event handler
     *
     * @param handler
     */
    mountEventHandler(handler) {
        this._handler = handler;
        return this;
    }
    /**
     * Dispatch an event
     *
     * @param e
     */
    dispatchEvent(e) {
        this.handler.dispatchEvent(e);
        return this;
    }
}

class Browser extends EventDriver {
    constructor({ apiUrl, accessToken, environmentId, }) {
        super();
        this._apiUrl = apiUrl;
        this._accessToken = accessToken;
        this._environmentId = environmentId || '';
    }
    mountEventHandler(handler) {
        handler.setVariables({
            accessToken: this._accessToken,
            apiUrl: this._apiUrl,
        });
        this._handler = handler;
        return this;
    }
}

/**
 * Flatfile's Virtual Machine is stateless / serverless. So when a new event
 * is handled, it will just call `handle(event)`.
 */
class FlatfileVirtualMachine extends EventDriver {
    /**
     * This method is triggered from within the Flatfile Core VM Runner. This
     * EventDriver does not have to listen for events because this method will
     * be invoked as necessary.
     *
     * @param event
     */
    handle(event) {
        this.dispatchEvent(event);
    }
    mountEventHandler(handler) {
        this._handler = handler;
        return this;
    }
}

/**
 * Backwards compatibility
 */
class Client extends FlatfileListener {
}

exports.AuthenticatedClient = AuthenticatedClient;
exports.Browser = Browser;
exports.Client = Client;
exports.EventDriver = EventDriver;
exports.EventHandler = EventHandler;
exports.FlatfileEvent = FlatfileEvent;
exports.FlatfileListener = FlatfileListener;
exports.FlatfileVirtualMachine = FlatfileVirtualMachine;
exports["default"] = FlatfileListener;
