import { AuthenticatedClient } from './authenticated.client';
import { EventCallback, FlatfileEvent } from './flatfile.event';
import type { Flatfile } from '@flatfile/api';
/**
 * EventHandler is a Flatfile flavored implementation of EventTarget
 */
export declare class EventHandler extends AuthenticatedClient {
    /**
     * Apply a filter to the values of an event
     */
    readonly filterQuery?: EventFilter;
    /**
     * Cache of registered listeners on this instance
     * @private
     */
    protected listeners: [string | string[], EventFilter, EventCallback][];
    constructor(filter?: EventFilter, accessToken?: string, apiUrl?: string);
    /**
     * Cache of registered child nodes for this listener. These nodes will
     * only receive events that pass the parent filter.
     *
     * @private
     */
    protected nodes: EventHandler[];
    /**
     * Register a subscriber for events that match this path
     */
    on(query: Arrayable<string>, callback: EventCallback): this;
    on(query: Arrayable<string>, filter: EventFilter, callback: EventCallback): this;
    /**
     * Add child nodes to send this event to as well
     *
     * @param node
     */
    addNode(node: EventHandler): this;
    /**
     * Dispatch an event and resolve the promise once it has completed (or
     * errored
     *
     * @todo - is there a right order in which to resolve event listeners?
     *   Should it matter?
     *
     * @param event
     */
    dispatchEvent(event: FlatfileEvent | Flatfile.Event | any): Promise<void>;
    /**
     * @deprecated legacy shim for receiving events from the VM layer
     * @alias dispatchEvent
     * @param event
     */
    routeEvent(event: Flatfile.Event): Promise<void>;
    /**
     * Actually trigger the event listeners on this particular target
     *
     * @note It is safer for now to run this in series to avoid IO locks and
     *       potential race conditions and uncaught errors
     *
     * @param event
     * @param recursive
     */
    trigger(event: FlatfileEvent, recursive?: boolean): Promise<void>;
    /**
     * Get any listeners from this target subscribing to this event
     *
     * @param event
     * @param recursive
     */
    getListeners(event: FlatfileEvent, recursive?: boolean): Listener[];
    /**
     * Attach more event listeners using a callback function. Used most
     * frequently for plugins.
     *
     * @param fn
     */
    use(fn: (handler: this) => void): this;
    /**
     * Filter an event out based on glob filter object
     *
     * @param event
     * @param filter
     */
    matchEvent(event: FlatfileEvent, filter: EventFilter | undefined): boolean;
}
export type EventFilter = Record<string, any>;
export type Arrayable<T> = T | Array<T>;
export type Listener = {
    query: string | string[];
    filter: any;
    callback: EventCallback;
};
//# sourceMappingURL=event.handler.d.ts.map